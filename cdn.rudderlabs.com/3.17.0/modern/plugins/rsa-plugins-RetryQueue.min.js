import {
    k as t,
    L as e,
    A as s,
    Q as i,
    a as r,
    B as a,
    l as h,
    _ as l,
    d as c,
    i as o
} from "./rsa-plugins-common.min.js";
let n = function(t) {
    return t[t.ASAP = 1] = "ASAP", t[t.RESCHEDULE = 2] = "RESCHEDULE", t[t.ABANDON = 3] = "ABANDON", t
}({});
const u = {
    setTimeout: (t, e) => globalThis.setTimeout(t, e),
    clearTimeout: t => globalThis.clearTimeout(t),
    Date: globalThis.Date,
    clockLateFactor: 2
};
class m {
    constructor() {
        this.tasks = {}, this.nextId = 1, this.clock = u
    }
    now() {
        return +new this.clock.Date
    }
    run(t, e, s) {
        const i = (this.nextId + 1).toString();
        return this.tasks[i] = this.clock.setTimeout(this.handle(i, t, e, s || n.ASAP), e), i
    }
    handle(t, e, s, i) {
        const r = this.now();
        return () => {
            delete this.tasks[t];
            const a = r + s * (this.clock.clockLateFactor || 2),
                h = this.now();
            if (!(i >= n.RESCHEDULE && a < h)) return e();
            i === n.RESCHEDULE && this.run(e, s, i)
        }
    }
    cancel(t) {
        this.tasks[t] && (this.clock.clearTimeout(this.tasks[t]), delete this.tasks[t])
    }
    cancelAll() {
        Object.values(this.tasks).forEach(this.clock.clearTimeout), this.tasks = {}
    }
}
const d = 1 / 0,
    g = 1 / 0,
    E = 524288,
    A = "Batch",
    p = "Single",
    b = (t, e) => t.time - e.time,
    y = "RetryQueue";
class S {
    constructor(t, r, a, h, l = e, c, o) {
        var n;
        this.storeManager = h, this.logger = c, this.name = t, this.id = s(), this.processQueueCb = a, this.batchSizeCalcCb = o, this.maxItems = r.maxItems || g, this.maxAttempts = r.maxAttempts || d, this.batch = {
            enabled: !1
        }, this.configureBatchMode(r), this.backoff = {
            minRetryDelay: r.minRetryDelay || 1e3,
            maxRetryDelay: r.maxRetryDelay || 3e4,
            factor: r.backoffFactor || 2,
            jitter: r.backoffJitter || 0
        };
        let u = Math.max(null !== (n = r.timerScaleFactor) && void 0 !== n ? n : 1, 1);
        u = Math.min(u, 10), this.timeouts = {
            ackTimer: Math.round(1e3 * u),
            reclaimTimer: Math.round(3e3 * u),
            reclaimTimeout: Math.round(1e4 * u),
            reclaimWait: Math.round(500 * u)
        }, this.schedule = new m, this.processId = "0", this.store = this.storeManager.setStore({
            id: this.id,
            name: this.name,
            validKeys: i,
            type: l,
            errorHandler: this.storeManager.errorHandler,
            logger: this.storeManager.logger
        }), this.setDefaultQueueEntries(), this.ack = this.ack.bind(this), this.checkReclaim = this.checkReclaim.bind(this), this.processHead = this.processHead.bind(this), this.flushBatch = this.flushBatch.bind(this), this.isPageAccessible = !0, this.flushBatchOnPageLeave(), this.scheduleTimeoutActive = !1
    }
    setDefaultQueueEntries() {
        this.setStorageEntry(i.IN_PROGRESS, {}), this.setStorageEntry(i.QUEUE, []), this.setStorageEntry(i.BATCH_QUEUE, [])
    }
    configureBatchMode(t) {
        if (this.batchingInProgress = !1, !r(t.batch)) return;
        const e = t.batch;
        var s, i, a;
        (this.batch.enabled = !0 === e.enabled, this.batch.enabled) && (this.batch.maxSize = Math.min(null !== (s = e.maxSize) && void 0 !== s ? s : E, E), this.batch.maxItems = null !== (i = e.maxItems) && void 0 !== i ? i : 100, this.batch.flushInterval = null !== (a = e.flushInterval) && void 0 !== a ? a : 6e4)
    }
    flushBatchOnPageLeave() {
        this.batch.enabled && a(this.flushBatch)
    }
    getStorageEntry(t) {
        return this.store.get(t)
    }
    setStorageEntry(t, e) {
        h(e) ? this.store.remove(t) : this.store.set(t, e)
    }
    stop() {
        this.schedule.cancelAll(), this.scheduleTimeoutActive = !1
    }
    start() {
        this.scheduleTimeoutActive && this.stop(), this.scheduleTimeoutActive = !0, this.scheduleFlushBatch(), this.ack(), this.checkReclaim(), this.processHead()
    }
    scheduleFlushBatch() {
        var t;
        this.batch.enabled && null !== (t = this.batch) && void 0 !== t && t.flushInterval && (this.flushBatchTaskId && this.schedule.cancel(this.flushBatchTaskId), this.flushBatchTaskId = this.schedule.run(this.flushBatch, this.batch.flushInterval, n.ASAP))
    }
    flushBatch(t = !0) {
        if (!this.batchingInProgress) {
            var e;
            this.isPageAccessible = t, this.batchingInProgress = !0;
            let s = null !== (e = this.getStorageEntry(i.BATCH_QUEUE)) && void 0 !== e ? e : [];
            if (s.length > 0) {
                s = s.slice(-s.length);
                const t = this.genQueueItem(s.map((t => t.item)), A);
                this.setStorageEntry(i.BATCH_QUEUE, []), this.pushToMainQueue(t)
            }
            this.batchingInProgress = !1, this.scheduleFlushBatch()
        }
    }
    shouldRetry(t, e) {
        return e <= this.maxAttempts
    }
    getDelay(t) {
        let e = this.backoff.minRetryDelay * this.backoff.factor ** t;
        if (this.backoff.jitter) {
            const t = Math.random(),
                s = Math.floor(t * this.backoff.jitter * e);
            Math.floor(10 * t) < 5 ? e -= s : e += s
        }
        return Number(Math.min(e, this.backoff.maxRetryDelay).toPrecision(1))
    }
    enqueue(t) {
        let e;
        e = this.batch.enabled && t.type === p ? this.handleNewItemForBatch(t) : t, e && this.pushToMainQueue(e)
    }
    handleNewItemForBatch(t) {
        var e;
        let s, r = null !== (e = this.getStorageEntry(i.BATCH_QUEUE)) && void 0 !== e ? e : [];
        if (this.batchingInProgress) r.push(t);
        else {
            this.batchingInProgress = !0, r = r.slice(-r.length), r.push(t);
            const e = this.getBatchDispatchInfo(r);
            if (e.criteriaMet || e.criteriaExceeded) {
                let i;
                if (e.criteriaExceeded ? (i = r.slice(0, r.length - 1), r = [t]) : (i = r, r = []), i.length > 0) {
                    const t = i.every((t => t.reclaimed)),
                        e = i.map((t => t.item));
                    s = t ? this.genQueueItem(e, A, !0) : this.genQueueItem(e, A)
                }
                this.scheduleFlushBatch()
            }
            this.batchingInProgress = !1
        }
        return this.setStorageEntry(i.BATCH_QUEUE, r), s
    }
    pushToMainQueue(t) {
        var e;
        let s = null !== (e = this.getStorageEntry(i.QUEUE)) && void 0 !== e ? e : [];
        s = this.maxItems > 1 ? s.slice(-(this.maxItems - 1)) : [], s.push(t), s = s.sort(b), this.setStorageEntry(i.QUEUE, s), this.scheduleTimeoutActive && this.processHead()
    }
    addItem(t) {
        this.enqueue(this.genQueueItem(t))
    }
    genQueueItem(t, e = p, i) {
        return l({
            item: t,
            attemptNumber: 0,
            time: this.schedule.now(),
            id: s(),
            type: e
        }, c(i) ? {
            reclaimed: i
        } : {})
    }
    requeue(t) {
        const {
            attemptNumber: e,
            item: i,
            type: r,
            id: a,
            firstAttemptedAt: h,
            lastAttemptedAt: l,
            reclaimed: c
        } = t, o = e + 1;
        this.shouldRetry(i, o) && this.enqueue({
            item: i,
            attemptNumber: o,
            time: this.schedule.now() + this.getDelay(o),
            id: null != a ? a : s(),
            type: r,
            firstAttemptedAt: h,
            lastAttemptedAt: l,
            reclaimed: c
        })
    }
    getBatchDispatchInfo(t) {
        var e, s;
        let i = !1,
            r = !1;
        const a = null === (e = this.batch) || void 0 === e ? void 0 : e.maxItems;
        if (c(a) && (i = t.length === a, r = t.length > a), i || r) return {
            criteriaMet: i,
            criteriaExceeded: r
        };
        let h = !1,
            l = !1;
        const o = null === (s = this.batch) || void 0 === s ? void 0 : s.maxSize;
        if (c(o) && c(this.batchSizeCalcCb)) {
            const e = this.batchSizeCalcCb(t.map((t => t.item)));
            h = e === o, l = e > o
        }
        return {
            criteriaMet: h,
            criteriaExceeded: l
        }
    }
    processHead() {
        var e, r, a;
        this.schedule.cancel(this.processId);
        let h = null !== (e = this.getStorageEntry(i.QUEUE)) && void 0 !== e ? e : [];
        const c = this.schedule.now(),
            o = [],
            u = (t, e) => (s, r) => {
                var a;
                const h = null !== (a = this.getStorageEntry(i.IN_PROGRESS)) && void 0 !== a ? a : {},
                    c = h[e],
                    o = null == c ? void 0 : c.firstAttemptedAt,
                    n = null == c ? void 0 : c.lastAttemptedAt;
                delete h[e], this.setStorageEntry(i.IN_PROGRESS, h), s && this.requeue(l(l({}, t), {}, {
                    firstAttemptedAt: o,
                    lastAttemptedAt: n
                }))
            },
            m = (t, e) => {
                o.push({
                    id: e,
                    item: t.item,
                    done: u(t, e),
                    attemptNumber: t.attemptNumber
                })
            };
        let d = null !== (r = this.getStorageEntry(i.IN_PROGRESS)) && void 0 !== r ? r : {};
        this.isPageAccessible || (d = {});
        let g = Object.keys(d).length;
        for (; h.length > 0 && h[0].time <= c && g++ < this.maxItems;) {
            const t = h.shift();
            if (t) {
                const e = s();
                this.isPageAccessible && (d[e] = {
                    item: t.item,
                    attemptNumber: t.attemptNumber,
                    time: this.schedule.now(),
                    type: t.type,
                    firstAttemptedAt: t.firstAttemptedAt,
                    lastAttemptedAt: t.lastAttemptedAt,
                    reclaimed: t.reclaimed
                }), m(t, e)
            }
        }
        if (this.setStorageEntry(i.QUEUE, h), this.setStorageEntry(i.IN_PROGRESS, d), o.forEach((e => {
                try {
                    var s, r, a, h;
                    const t = this.schedule.now(),
                        l = null !== (s = this.getStorageEntry(i.IN_PROGRESS)) && void 0 !== s ? s : {},
                        c = l[e.id],
                        o = null !== (r = null == c ? void 0 : c.firstAttemptedAt) && void 0 !== r ? r : t,
                        n = null !== (a = null == c ? void 0 : c.lastAttemptedAt) && void 0 !== a ? a : t,
                        u = Math.round((t - o) / 1e3),
                        m = Math.round((t - n) / 1e3),
                        d = null !== (h = null == c ? void 0 : c.reclaimed) && void 0 !== h && h;
                    c.firstAttemptedAt = o, c.lastAttemptedAt = t, l[e.id] = c, this.setStorageEntry(i.IN_PROGRESS, l);
                    const g = this.shouldRetry(e.item, e.attemptNumber + 1);
                    this.processQueueCb(e.item, e.done, {
                        retryAttemptNumber: e.attemptNumber,
                        maxRetryAttempts: this.maxAttempts,
                        willBeRetried: g,
                        timeSinceFirstAttempt: u,
                        timeSinceLastAttempt: m,
                        reclaimed: d
                    })
                } catch (s) {
                    var l;
                    let i = "";
                    e.attemptNumber < this.maxAttempts ? (i = "The item will be requeued.", e.attemptNumber > 0 && (i = `${i} Retry attempt ${e.attemptNumber} of ${this.maxAttempts}.`), e.done(s)) : (i = `Retries exhausted (${this.maxAttempts}). The item will be dropped.`, e.done()), null === (l = this.logger) || void 0 === l || l.error(((e, s) => `${e}${t}An unknown error occurred while processing the queue item. ${s}`)(y, i), s)
                }
            })), h = null !== (a = this.getStorageEntry(i.QUEUE)) && void 0 !== a ? a : [], this.schedule.cancel(this.processId), h.length > 0) {
            const t = h[0].time - c;
            this.processId = this.schedule.run(this.processHead, t, n.ASAP)
        }
    }
    ack() {
        this.setStorageEntry(i.ACK, this.schedule.now()), null != this.reclaimStartVal && (this.reclaimStartVal = null, this.setStorageEntry(i.RECLAIM_START, null)), null != this.reclaimEndVal && (this.reclaimEndVal = null, this.setStorageEntry(i.RECLAIM_END, null)), this.schedule.run(this.ack, this.timeouts.ackTimer, n.ASAP)
    }
    reclaim(t) {
        var r, a, h, c;
        const o = this.storeManager.setStore({
                id: t,
                name: this.name,
                validKeys: i,
                type: e,
                errorHandler: this.storeManager.errorHandler,
                logger: this.storeManager.logger
            }),
            n = {
                queue: null !== (r = this.getStorageEntry(i.QUEUE)) && void 0 !== r ? r : []
            },
            u = {
                inProgress: null !== (a = o.get(i.IN_PROGRESS)) && void 0 !== a ? a : {},
                batchQueue: null !== (h = o.get(i.BATCH_QUEUE)) && void 0 !== h ? h : [],
                queue: null !== (c = o.get(i.QUEUE)) && void 0 !== c ? c : []
            },
            m = [],
            d = (t, e) => {
                const i = t => {
                    var i;
                    const r = null !== (i = t.id) && void 0 !== i ? i : s();
                    if (m.includes(r));
                    else {
                        var a;
                        const s = Array.isArray(t.item) ? A : p;
                        n.queue.push({
                            item: t.item,
                            attemptNumber: t.attemptNumber + e,
                            time: this.schedule.now(),
                            id: r,
                            type: null !== (a = t.type) && void 0 !== a ? a : s,
                            firstAttemptedAt: t.firstAttemptedAt,
                            lastAttemptedAt: t.lastAttemptedAt,
                            reclaimed: !0
                        }), m.push(r)
                    }
                };
                Array.isArray(t) ? t.forEach(i) : t && Object.values(t).forEach(i)
            };
        d(u.queue, 0), this.batch.enabled ? u.batchQueue.forEach((t => {
            var e;
            const i = null !== (e = t.id) && void 0 !== e ? e : s();
            var r;
            m.includes(i) || (this.enqueue(l(l({}, t), {}, {
                id: i,
                reclaimed: !0,
                type: null !== (r = t.type) && void 0 !== r ? r : p,
                time: this.schedule.now()
            })), m.push(i))
        })) : d(u.batchQueue, 0), d(u.inProgress, 1), n.queue.sort(b), this.setStorageEntry(i.QUEUE, n.queue), this.clearQueueEntries(o, 1), this.processHead()
    }
    clearQueueEntries(t, e) {
        this.removeStorageEntry(t, 0, e)
    }
    removeStorageEntry(e, s, r, a = 1) {
        const h = Object.keys(i),
            l = i[h[s]];
        globalThis.setTimeout((() => {
            try {
                e.remove(l), s + 1 < h.length && this.removeStorageEntry(e, s + 1, r)
            } catch (c) {
                const o = "NS_ERROR_STORAGE_BUSY";
                var i;
                if ((c.name === o || c.code === o || 2153971713 === c.code) && a < 2) this.removeStorageEntry(e, s, r + 40, a + 1);
                else null === (i = this.logger) || void 0 === i || i.error(((e, s, i) => `${e}${t}Failed to remove local storage entry "${s}" (attempt: ${i}.`)(y, l, a), c);
                2 === a && s + 1 < h.length && this.removeStorageEntry(e, s + 1, r)
            }
        }), r)
    }
    checkReclaim() {
        const t = t => () => {
                t.get(i.RECLAIM_END) === this.id && t.get(i.RECLAIM_START) === this.id && this.reclaim(t.id)
            },
            s = e => () => {
                e.get(i.RECLAIM_START) === this.id && (e.set(i.RECLAIM_END, this.id), this.schedule.run(t(e), this.timeouts.reclaimWait, n.ABANDON))
            },
            r = t => {
                t.set(i.RECLAIM_START, this.id), t.set(i.ACK, this.schedule.now()), this.schedule.run(s(t), this.timeouts.reclaimWait, n.ABANDON)
            };
        (t => {
            const s = [],
                r = this.store.getOriginalEngine();
            let a = [];
            if (o(r.keys)) a = r.keys();
            else
                for (let t = 0; t < r.length; t++) {
                    const e = r.key(t);
                    e && a.push(e)
                }
            return a.forEach((r => {
                const a = r ? r.split(".") : [];
                a.length >= 3 && a[0] === t && a[1] !== this.id && a[2] === i.ACK && s.push(this.storeManager.setStore({
                    id: a[1],
                    name: t,
                    validKeys: i,
                    type: e,
                    errorHandler: this.storeManager.errorHandler,
                    logger: this.storeManager.logger
                }))
            })), s
        })(this.name).forEach((t => {
            this.schedule.now() - t.get(i.ACK) < this.timeouts.reclaimTimeout || r(t)
        })), this.schedule.run(this.checkReclaim, this.timeouts.reclaimTimer, n.RESCHEDULE)
    }
    clear() {
        this.schedule.cancelAll(), this.setDefaultQueueEntries()
    }
}
export {
    S as R
};
//# sourceMappingURL=rsa-plugins-RetryQueue.min.js.map