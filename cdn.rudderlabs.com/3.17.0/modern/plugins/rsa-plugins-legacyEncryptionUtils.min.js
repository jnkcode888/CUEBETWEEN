import {
    D as t
} from "./rsa-plugins-common.min.js";
var e, s, r, n, o;
const i = (null === (e = "undefined" != typeof globalThis ? globalThis : void 0) || void 0 === e ? void 0 : e.crypto) || (null === (s = "undefined" != typeof global ? global : void 0) || void 0 === s ? void 0 : s.crypto) || (null === (r = "undefined" != typeof window ? window : void 0) || void 0 === r ? void 0 : r.crypto) || (null === (n = "undefined" != typeof self ? self : void 0) || void 0 === n ? void 0 : n.crypto) || (null === (o = "undefined" != typeof frames ? frames : void 0) || void 0 === o || null === (o = o[0]) || void 0 === o ? void 0 : o.crypto);
let c;
c = i ? t => {
    const e = [];
    for (let s = 0; s < t; s += 4) e.push(i.getRandomValues(new Uint32Array(1))[0]);
    return new l(e, t)
} : t => {
    const e = [],
        s = t => {
            let e = t,
                s = 987654321;
            const r = 4294967295;
            return () => {
                s = 36969 * (65535 & s) + (s >> 16) & r, e = 18e3 * (65535 & e) + (e >> 16) & r;
                let t = (s << 16) + e & r;
                return t /= 4294967296, t += .5, t * (Math.random() > .5 ? 1 : -1)
            }
        };
    for (let r, n = 0; n < t; n += 4) {
        const t = s(4294967296 * (r || Math.random()));
        r = 987654071 * t(), e.push(4294967296 * t() | 0)
    }
    return new l(e, t)
};
class a {
    static create(...t) {
        return new this(...t)
    }
    mixIn(t) {
        return Object.assign(this, t)
    }
    clone() {
        const t = new this.constructor;
        return Object.assign(t, this), t
    }
}
class l extends a {
    constructor(t = [], e = 4 * t.length) {
        super();
        let s = t;
        if (s instanceof ArrayBuffer && (s = new Uint8Array(s)), (s instanceof Int8Array || s instanceof Uint8ClampedArray || s instanceof Int16Array || s instanceof Uint16Array || s instanceof Int32Array || s instanceof Uint32Array || s instanceof Float32Array || s instanceof Float64Array) && (s = new Uint8Array(s.buffer, s.byteOffset, s.byteLength)), s instanceof Uint8Array) {
            const t = s.byteLength,
                e = [];
            for (let r = 0; r < t; r += 1) e[r >>> 2] |= s[r] << 24 - r % 4 * 8;
            this.words = e, this.sigBytes = t
        } else this.words = t, this.sigBytes = e
    }
    toString(t = h) {
        return t.stringify(this)
    }
    concat(t) {
        const e = this.words,
            s = t.words,
            r = this.sigBytes,
            n = t.sigBytes;
        if (this.clamp(), r % 4)
            for (let t = 0; t < n; t += 1) {
                const n = s[t >>> 2] >>> 24 - t % 4 * 8 & 255;
                e[r + t >>> 2] |= n << 24 - (r + t) % 4 * 8
            } else
                for (let t = 0; t < n; t += 4) e[r + t >>> 2] = s[t >>> 2];
        return this.sigBytes += n, this
    }
    clamp() {
        const {
            words: t,
            sigBytes: e
        } = this;
        t[e >>> 2] &= 4294967295 << 32 - e % 4 * 8, t.length = Math.ceil(e / 4)
    }
    clone() {
        const t = super.clone.call(this);
        return t.words = this.words.slice(0), t
    }
}
t(l, "random", c);
const h = {
        stringify(t) {
            const {
                words: e,
                sigBytes: s
            } = t, r = [];
            for (let t = 0; t < s; t += 1) {
                const s = e[t >>> 2] >>> 24 - t % 4 * 8 & 255;
                r.push((s >>> 4).toString(16)), r.push((15 & s).toString(16))
            }
            return r.join("")
        },
        parse(t) {
            const e = t.length,
                s = [];
            for (let r = 0; r < e; r += 2) s[r >>> 3] |= parseInt(t.substr(r, 2), 16) << 24 - r % 8 * 4;
            return new l(s, e / 2)
        }
    },
    d = {
        stringify(t) {
            const {
                words: e,
                sigBytes: s
            } = t, r = [];
            for (let t = 0; t < s; t += 1) {
                const s = e[t >>> 2] >>> 24 - t % 4 * 8 & 255;
                r.push(String.fromCharCode(s))
            }
            return r.join("")
        },
        parse(t) {
            const e = t.length,
                s = [];
            for (let r = 0; r < e; r += 1) s[r >>> 2] |= (255 & t.charCodeAt(r)) << 24 - r % 4 * 8;
            return new l(s, e)
        }
    },
    p = {
        stringify(t) {
            try {
                return decodeURIComponent(escape(d.stringify(t)))
            } catch (t) {
                throw new Error("Malformed UTF-8 data")
            }
        },
        parse: t => d.parse(unescape(encodeURIComponent(t)))
    };
class u extends a {
    constructor() {
        super(), this._minBufferSize = 0
    }
    reset() {
        this._data = new l, this._nDataBytes = 0
    }
    _append(t) {
        let e = t;
        "string" == typeof e && (e = p.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes
    }
    _process(t) {
        let e;
        const {
            _data: s,
            blockSize: r
        } = this, n = s.words, o = s.sigBytes;
        let i = o / (4 * r);
        i = t ? Math.ceil(i) : Math.max((0 | i) - this._minBufferSize, 0);
        const c = i * r,
            a = Math.min(4 * c, o);
        if (c) {
            for (let t = 0; t < c; t += r) this._doProcessBlock(n, t);
            e = n.splice(0, c), s.sigBytes -= a
        }
        return new l(e, a)
    }
    clone() {
        const t = super.clone.call(this);
        return t._data = this._data.clone(), t
    }
}
class f extends u {
    constructor(t) {
        super(), this.blockSize = 16, this.cfg = Object.assign(new a, t), this.reset()
    }
    static _createHelper(t) {
        return (e, s) => new t(s).finalize(e)
    }
    static _createHmacHelper(t) {
        return (e, s) => new y(t, s).finalize(e)
    }
    reset() {
        super.reset.call(this), this._doReset()
    }
    update(t) {
        return this._append(t), this._process(), this
    }
    finalize(t) {
        t && this._append(t);
        return this._doFinalize()
    }
}
class y extends a {
    constructor(t, e) {
        super();
        const s = new t;
        this._hasher = s;
        let r = e;
        "string" == typeof r && (r = p.parse(r));
        const n = s.blockSize,
            o = 4 * n;
        r.sigBytes > o && (r = s.finalize(e)), r.clamp();
        const i = r.clone();
        this._oKey = i;
        const c = r.clone();
        this._iKey = c;
        const a = i.words,
            l = c.words;
        for (let t = 0; t < n; t += 1) a[t] ^= 1549556828, l[t] ^= 909522486;
        i.sigBytes = o, c.sigBytes = o, this.reset()
    }
    reset() {
        const t = this._hasher;
        t.reset(), t.update(this._iKey)
    }
    update(t) {
        return this._hasher.update(t), this
    }
    finalize(t) {
        const e = this._hasher,
            s = e.finalize(t);
        e.reset();
        return e.finalize(this._oKey.clone().concat(s))
    }
}
const _ = {
        stringify(t) {
            const {
                words: e,
                sigBytes: s
            } = t, r = this._map;
            t.clamp();
            const n = [];
            for (let t = 0; t < s; t += 3) {
                const o = (e[t >>> 2] >>> 24 - t % 4 * 8 & 255) << 16 | (e[t + 1 >>> 2] >>> 24 - (t + 1) % 4 * 8 & 255) << 8 | e[t + 2 >>> 2] >>> 24 - (t + 2) % 4 * 8 & 255;
                for (let e = 0; e < 4 && t + .75 * e < s; e += 1) n.push(r.charAt(o >>> 6 * (3 - e) & 63))
            }
            const o = r.charAt(64);
            if (o)
                for (; n.length % 4;) n.push(o);
            return n.join("")
        },
        parse(t) {
            let e = t.length;
            const s = this._map;
            let r = this._reverseMap;
            if (!r) {
                this._reverseMap = [], r = this._reverseMap;
                for (let t = 0; t < s.length; t += 1) r[s.charCodeAt(t)] = t
            }
            const n = s.charAt(64);
            if (n) {
                const s = t.indexOf(n); - 1 !== s && (e = s)
            }
            return ((t, e, s) => {
                const r = [];
                let n = 0;
                for (let o = 0; o < e; o += 1)
                    if (o % 4) {
                        const e = s[t.charCodeAt(o - 1)] << o % 4 * 2 | s[t.charCodeAt(o)] >>> 6 - o % 4 * 2;
                        r[n >>> 2] |= e << 24 - n % 4 * 8, n += 1
                    }
                return l.create(r, n)
            })(t, e, r)
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    },
    g = [];
for (let t = 0; t < 64; t += 1) g[t] = 4294967296 * Math.abs(Math.sin(t + 1)) | 0;
const w = (t, e, s, r, n, o, i) => {
        const c = t + (e & s | ~e & r) + n + i;
        return (c << o | c >>> 32 - o) + e
    },
    m = (t, e, s, r, n, o, i) => {
        const c = t + (e & r | s & ~r) + n + i;
        return (c << o | c >>> 32 - o) + e
    },
    k = (t, e, s, r, n, o, i) => {
        const c = t + (e ^ s ^ r) + n + i;
        return (c << o | c >>> 32 - o) + e
    },
    B = (t, e, s, r, n, o, i) => {
        const c = t + (s ^ (e | ~r)) + n + i;
        return (c << o | c >>> 32 - o) + e
    };
class v extends f {
    _doReset() {
        this._hash = new l([1732584193, 4023233417, 2562383102, 271733878])
    }
    _doProcessBlock(t, e) {
        const s = t;
        for (let r = 0; r < 16; r += 1) {
            const n = e + r,
                o = t[n];
            s[n] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
        }
        const r = this._hash.words,
            n = s[e + 0],
            o = s[e + 1],
            i = s[e + 2],
            c = s[e + 3],
            a = s[e + 4],
            l = s[e + 5],
            h = s[e + 6],
            d = s[e + 7],
            p = s[e + 8],
            u = s[e + 9],
            f = s[e + 10],
            y = s[e + 11],
            _ = s[e + 12],
            v = s[e + 13],
            z = s[e + 14],
            S = s[e + 15];
        let x = r[0],
            b = r[1],
            M = r[2],
            O = r[3];
        x = w(x, b, M, O, n, 7, g[0]), O = w(O, x, b, M, o, 12, g[1]), M = w(M, O, x, b, i, 17, g[2]), b = w(b, M, O, x, c, 22, g[3]), x = w(x, b, M, O, a, 7, g[4]), O = w(O, x, b, M, l, 12, g[5]), M = w(M, O, x, b, h, 17, g[6]), b = w(b, M, O, x, d, 22, g[7]), x = w(x, b, M, O, p, 7, g[8]), O = w(O, x, b, M, u, 12, g[9]), M = w(M, O, x, b, f, 17, g[10]), b = w(b, M, O, x, y, 22, g[11]), x = w(x, b, M, O, _, 7, g[12]), O = w(O, x, b, M, v, 12, g[13]), M = w(M, O, x, b, z, 17, g[14]), b = w(b, M, O, x, S, 22, g[15]), x = m(x, b, M, O, o, 5, g[16]), O = m(O, x, b, M, h, 9, g[17]), M = m(M, O, x, b, y, 14, g[18]), b = m(b, M, O, x, n, 20, g[19]), x = m(x, b, M, O, l, 5, g[20]), O = m(O, x, b, M, f, 9, g[21]), M = m(M, O, x, b, S, 14, g[22]), b = m(b, M, O, x, a, 20, g[23]), x = m(x, b, M, O, u, 5, g[24]), O = m(O, x, b, M, z, 9, g[25]), M = m(M, O, x, b, c, 14, g[26]), b = m(b, M, O, x, p, 20, g[27]), x = m(x, b, M, O, v, 5, g[28]), O = m(O, x, b, M, i, 9, g[29]), M = m(M, O, x, b, d, 14, g[30]), b = m(b, M, O, x, _, 20, g[31]), x = k(x, b, M, O, l, 4, g[32]), O = k(O, x, b, M, p, 11, g[33]), M = k(M, O, x, b, y, 16, g[34]), b = k(b, M, O, x, z, 23, g[35]), x = k(x, b, M, O, o, 4, g[36]), O = k(O, x, b, M, a, 11, g[37]), M = k(M, O, x, b, d, 16, g[38]), b = k(b, M, O, x, f, 23, g[39]), x = k(x, b, M, O, v, 4, g[40]), O = k(O, x, b, M, n, 11, g[41]), M = k(M, O, x, b, c, 16, g[42]), b = k(b, M, O, x, h, 23, g[43]), x = k(x, b, M, O, u, 4, g[44]), O = k(O, x, b, M, _, 11, g[45]), M = k(M, O, x, b, S, 16, g[46]), b = k(b, M, O, x, i, 23, g[47]), x = B(x, b, M, O, n, 6, g[48]), O = B(O, x, b, M, d, 10, g[49]), M = B(M, O, x, b, z, 15, g[50]), b = B(b, M, O, x, l, 21, g[51]), x = B(x, b, M, O, _, 6, g[52]), O = B(O, x, b, M, c, 10, g[53]), M = B(M, O, x, b, f, 15, g[54]), b = B(b, M, O, x, o, 21, g[55]), x = B(x, b, M, O, p, 6, g[56]), O = B(O, x, b, M, S, 10, g[57]), M = B(M, O, x, b, h, 15, g[58]), b = B(b, M, O, x, v, 21, g[59]), x = B(x, b, M, O, a, 6, g[60]), O = B(O, x, b, M, y, 10, g[61]), M = B(M, O, x, b, i, 15, g[62]), b = B(b, M, O, x, u, 21, g[63]), r[0] = r[0] + x | 0, r[1] = r[1] + b | 0, r[2] = r[2] + M | 0, r[3] = r[3] + O | 0
    }
    _doFinalize() {
        const t = this._data,
            e = t.words,
            s = 8 * this._nDataBytes,
            r = 8 * t.sigBytes;
        e[r >>> 5] |= 128 << 24 - r % 32;
        const n = Math.floor(s / 4294967296),
            o = s;
        e[15 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), e[14 + (r + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), t.sigBytes = 4 * (e.length + 1), this._process();
        const i = this._hash,
            c = i.words;
        for (let t = 0; t < 4; t += 1) {
            const e = c[t];
            c[t] = 16711935 & (e << 8 | e >>> 24) | 4278255360 & (e << 24 | e >>> 8)
        }
        return i
    }
    clone() {
        const t = super.clone.call(this);
        return t._hash = this._hash.clone(), t
    }
}
class z extends a {
    constructor(t) {
        super(), this.cfg = Object.assign(new a, {
            keySize: 4,
            hasher: v,
            iterations: 1
        }, t)
    }
    compute(t, e) {
        let s;
        const {
            cfg: r
        } = this, n = r.hasher.create(), o = l.create(), i = o.words, {
            keySize: c,
            iterations: a
        } = r;
        for (; i.length < c;) {
            s && n.update(s), s = n.update(t).finalize(e), n.reset();
            for (let t = 1; t < a; t += 1) s = n.finalize(s), n.reset();
            o.concat(s)
        }
        return o.sigBytes = 4 * c, o
    }
}
const S = "function" != typeof Object.assign ? function(t) {
    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
    t = Object(t);
    for (let e = 1; e < arguments.length; e++) {
        const s = arguments[e];
        if (null != s)
            for (const e in s) Object.prototype.hasOwnProperty.call(s, e) && (t[e] = s[e])
    }
    return t
} : Object.assign;
class x extends u {
    constructor(t, e, s) {
        super(), this.cfg = S(new a, s), this._xformMode = t, this._key = e, this.reset()
    }
    static createEncryptor(t, e) {
        return this.create(this._ENC_XFORM_MODE, t, e)
    }
    static createDecryptor(t, e) {
        return this.create(this._DEC_XFORM_MODE, t, e)
    }
    static _createHelper(t) {
        const e = t => "string" == typeof t ? F : D;
        return {
            encrypt: (s, r, n) => e(r).encrypt(t, s, r, n),
            decrypt: (s, r, n) => e(r).decrypt(t, s, r, n)
        }
    }
    reset() {
        super.reset.call(this), this._doReset()
    }
    process(t) {
        return this._append(t), this._process()
    }
    finalize(t) {
        t && this._append(t);
        return this._doFinalize()
    }
}
x._ENC_XFORM_MODE = 1, x._DEC_XFORM_MODE = 2, x.keySize = 4, x.ivSize = 4;
class b extends a {
    constructor(t, e) {
        super(), this._cipher = t, this._iv = e
    }
    static createEncryptor(t, e) {
        return this.Encryptor.create(t, e)
    }
    static createDecryptor(t, e) {
        return this.Decryptor.create(t, e)
    }
}

function M(t, e, s) {
    const r = t;
    let n;
    const o = this._iv;
    o ? (n = o, this._iv = void 0) : n = this._prevBlock;
    for (let t = 0; t < s; t += 1) r[e + t] ^= n[t]
}
class O extends b {}
O.Encryptor = class extends O {
    processBlock(t, e) {
        const s = this._cipher,
            {
                blockSize: r
            } = s;
        M.call(this, t, e, r), s.encryptBlock(t, e), this._prevBlock = t.slice(e, e + r)
    }
}, O.Decryptor = class extends O {
    processBlock(t, e) {
        const s = this._cipher,
            {
                blockSize: r
            } = s,
            n = t.slice(e, e + r);
        s.decryptBlock(t, e), M.call(this, t, e, r), this._prevBlock = n
    }
};
const R = {
    pad(t, e) {
        const s = 4 * e,
            r = s - t.sigBytes % s,
            n = r << 24 | r << 16 | r << 8 | r,
            o = [];
        for (let t = 0; t < r; t += 4) o.push(n);
        const i = l.create(o, r);
        t.concat(i)
    },
    unpad(t) {
        const e = t,
            s = 255 & e.words[e.sigBytes - 1 >>> 2];
        e.sigBytes -= s
    }
};
class E extends x {
    constructor(t, e, s) {
        super(t, e, S({
            mode: O,
            padding: R
        }, s)), this.blockSize = 4
    }
    reset() {
        let t;
        super.reset.call(this);
        const {
            cfg: e
        } = this, {
            iv: s,
            mode: r
        } = e;
        this._xformMode === this.constructor._ENC_XFORM_MODE ? t = r.createEncryptor : (t = r.createDecryptor, this._minBufferSize = 1), this._mode = t.call(r, this, s && s.words), this._mode.__creator = t
    }
    _doProcessBlock(t, e) {
        this._mode.processBlock(t, e)
    }
    _doFinalize() {
        let t;
        const {
            padding: e
        } = this.cfg;
        return this._xformMode === this.constructor._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize), t = this._process(!0)) : (t = this._process(!0), e.unpad(t)), t
    }
}
class A extends a {
    constructor(t) {
        super(), this.mixIn(t)
    }
    toString(t) {
        return (t || this.formatter).stringify(this)
    }
}
const C = {
    stringify(t) {
        let e;
        const {
            ciphertext: s,
            salt: r
        } = t;
        return e = r ? l.create([1398893684, 1701076831]).concat(r).concat(s) : s, e.toString(_)
    },
    parse(t) {
        let e;
        const s = _.parse(t),
            r = s.words;
        return 1398893684 === r[0] && 1701076831 === r[1] && (e = l.create(r.slice(2, 4)), r.splice(0, 4), s.sigBytes -= 16), A.create({
            ciphertext: s,
            salt: e
        })
    }
};
class D extends a {
    static encrypt(t, e, s, r) {
        const n = S(new a, this.cfg, r),
            o = t.createEncryptor(s, n),
            i = o.finalize(e),
            c = o.cfg;
        return A.create({
            ciphertext: i,
            key: s,
            iv: c.iv,
            algorithm: t,
            mode: c.mode,
            padding: c.padding,
            blockSize: o.blockSize,
            formatter: n.format
        })
    }
    static decrypt(t, e, s, r) {
        let n = e;
        const o = S(new a, this.cfg, r);
        n = this._parse(n, o.format);
        return t.createDecryptor(s, o).finalize(n.ciphertext)
    }
    static _parse(t, e) {
        return "string" == typeof t ? e.parse(t, this) : t
    }
}
D.cfg = S(new a, {
    format: C
});
const j = {
    execute(t, e, s, r, n) {
        let o, i = r;
        i || (i = l.random(8)), o = n ? z.create({
            keySize: e + s,
            hasher: n
        }).compute(t, i) : z.create({
            keySize: e + s
        }).compute(t, i);
        const c = l.create(o.words.slice(e), 4 * s);
        return o.sigBytes = 4 * e, A.create({
            key: o,
            iv: c,
            salt: i
        })
    }
};
class F extends D {
    static encrypt(t, e, s, r) {
        const n = S(new a, this.cfg, r),
            o = n.kdf.execute(s, t.keySize, t.ivSize, n.salt, n.hasher);
        n.iv = o.iv;
        const i = D.encrypt.call(this, t, e, o.key, n);
        return i.mixIn(o), i
    }
    static decrypt(t, e, s, r) {
        let n = e;
        const o = S(new a, this.cfg, r);
        n = this._parse(n, o.format);
        const i = o.kdf.execute(s, t.keySize, t.ivSize, n.salt, o.hasher);
        o.iv = i.iv;
        return D.decrypt.call(this, t, n, i.key, o)
    }
}
F.cfg = S(D.cfg, {
    kdf: j
});
const U = [],
    I = [],
    K = [],
    P = [],
    X = [],
    H = [],
    N = [],
    T = [],
    L = [],
    V = [],
    W = [];
for (let t = 0; t < 256; t += 1) W[t] = t < 128 ? t << 1 : t << 1 ^ 283;
let $ = 0,
    q = 0;
for (let t = 0; t < 256; t += 1) {
    let t = q ^ q << 1 ^ q << 2 ^ q << 3 ^ q << 4;
    t = t >>> 8 ^ 255 & t ^ 99, U[$] = t, I[t] = $;
    const e = W[$],
        s = W[e],
        r = W[s];
    let n = 257 * W[t] ^ 16843008 * t;
    K[$] = n << 24 | n >>> 8, P[$] = n << 16 | n >>> 16, X[$] = n << 8 | n >>> 24, H[$] = n, n = 16843009 * r ^ 65537 * s ^ 257 * e ^ 16843008 * $, N[t] = n << 24 | n >>> 8, T[t] = n << 16 | n >>> 16, L[t] = n << 8 | n >>> 24, V[t] = n, $ ? ($ = e ^ W[W[W[r ^ e]]], q ^= W[W[q]]) : (q = 1, $ = q)
}
const G = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
class J extends E {
    _doReset() {
        let t;
        if (this._nRounds && this._keyPriorReset === this._key) return;
        this._keyPriorReset = this._key;
        const e = this._keyPriorReset,
            s = e.words,
            r = e.sigBytes / 4;
        this._nRounds = r + 6;
        const n = 4 * (this._nRounds + 1);
        this._keySchedule = [];
        const o = this._keySchedule;
        for (let e = 0; e < n; e += 1) e < r ? o[e] = s[e] : (t = o[e - 1], e % r ? r > 6 && e % r == 4 && (t = U[t >>> 24] << 24 | U[t >>> 16 & 255] << 16 | U[t >>> 8 & 255] << 8 | U[255 & t]) : (t = t << 8 | t >>> 24, t = U[t >>> 24] << 24 | U[t >>> 16 & 255] << 16 | U[t >>> 8 & 255] << 8 | U[255 & t], t ^= G[e / r | 0] << 24), o[e] = o[e - r] ^ t);
        this._invKeySchedule = [];
        const i = this._invKeySchedule;
        for (let e = 0; e < n; e += 1) {
            const s = n - e;
            t = e % 4 ? o[s] : o[s - 4], i[e] = e < 4 || s <= 4 ? t : N[U[t >>> 24]] ^ T[U[t >>> 16 & 255]] ^ L[U[t >>> 8 & 255]] ^ V[U[255 & t]]
        }
    }
    encryptBlock(t, e) {
        this._doCryptBlock(t, e, this._keySchedule, K, P, X, H, U)
    }
    decryptBlock(t, e) {
        const s = t;
        let r = s[e + 1];
        s[e + 1] = s[e + 3], s[e + 3] = r, this._doCryptBlock(s, e, this._invKeySchedule, N, T, L, V, I), r = s[e + 1], s[e + 1] = s[e + 3], s[e + 3] = r
    }
    _doCryptBlock(t, e, s, r, n, o, i, c) {
        const a = t,
            l = this._nRounds;
        let h = a[e] ^ s[0],
            d = a[e + 1] ^ s[1],
            p = a[e + 2] ^ s[2],
            u = a[e + 3] ^ s[3],
            f = 4;
        for (let t = 1; t < l; t += 1) {
            const t = r[h >>> 24] ^ n[d >>> 16 & 255] ^ o[p >>> 8 & 255] ^ i[255 & u] ^ s[f];
            f += 1;
            const e = r[d >>> 24] ^ n[p >>> 16 & 255] ^ o[u >>> 8 & 255] ^ i[255 & h] ^ s[f];
            f += 1;
            const c = r[p >>> 24] ^ n[u >>> 16 & 255] ^ o[h >>> 8 & 255] ^ i[255 & d] ^ s[f];
            f += 1;
            const a = r[u >>> 24] ^ n[h >>> 16 & 255] ^ o[d >>> 8 & 255] ^ i[255 & p] ^ s[f];
            f += 1, h = t, d = e, p = c, u = a
        }
        const y = (c[h >>> 24] << 24 | c[d >>> 16 & 255] << 16 | c[p >>> 8 & 255] << 8 | c[255 & u]) ^ s[f];
        f += 1;
        const _ = (c[d >>> 24] << 24 | c[p >>> 16 & 255] << 16 | c[u >>> 8 & 255] << 8 | c[255 & h]) ^ s[f];
        f += 1;
        const g = (c[p >>> 24] << 24 | c[u >>> 16 & 255] << 16 | c[h >>> 8 & 255] << 8 | c[255 & d]) ^ s[f];
        f += 1;
        const w = (c[u >>> 24] << 24 | c[h >>> 16 & 255] << 16 | c[d >>> 8 & 255] << 8 | c[255 & p]) ^ s[f];
        f += 1, a[e] = y, a[e + 1] = _, a[e + 2] = g, a[e + 3] = w
    }
}
J.keySize = 8;
const Q = E._createHelper(J),
    Y = "RudderEncrypt:",
    Z = "Rudder",
    tt = t => `${Y}${Q.encrypt(t,Z).toString()}`,
    et = t => t.startsWith(Y) ? Q.decrypt(t.substring(14), Z).toString(p) : t;
export {
    et as d, tt as e
};
//# sourceMappingURL=rsa-plugins-legacyEncryptionUtils.min.js.map