import {
    k as e,
    m as t,
    r as a,
    n as r,
    o as n,
    c as s,
    y as l,
    s as i,
    v as u,
    z as o,
    g as d,
    w as m,
    L as v
} from "./rsa-plugins-common.min.js";
import {
    R as c
} from "./rsa-plugins-RetryQueue.min.js";
const p = {
        maxRetryDelay: 36e4,
        minRetryDelay: 1e3,
        backoffFactor: 2,
        maxAttempts: 10,
        maxItems: 100
    },
    y = "v1",
    A = (e, t, a) => i({
        batch: e,
        sentAt: t
    }, !0, void 0, a),
    h = (e, t) => {
        const r = new URL(e);
        return new URL(a([r.pathname, "/", y, "/", t].join("")), r).href
    },
    R = (t, a, r, n) => {
        var s, l;
        let i = (u = "XhrQueuePlugin", o = null !== (s = null == t || null === (l = t.error) || void 0 === l ? void 0 : l.message) && void 0 !== s ? s : "Unknown", `${u}${e}Failed to deliver event(s). Cause: ${o}.`);
        var u, o;
        const d = "The event(s) will be dropped.";
        a ? r.willBeRetried ? (i = `${i} The event(s) will be retried.`, r.retryAttemptNumber > 0 && (i = `${i} Retry attempt ${r.retryAttemptNumber} of ${r.maxRetryAttempts}.`)) : i = `${i} Retries exhausted (${r.maxRetryAttempts}). ${d}` : i = `${i} ${d}`, null == n || n.error(i)
    },
    f = (e, t, a, i) => {
        let u, o, d;
        const m = r();
        if (Array.isArray(e)) {
            const a = e.map((e => n(e.event, m)));
            u = A(a, m, i), o = e[0] ? s(e[0].headers) : {}, v = t.lifecycle.activeDataplaneUrl.value, d = h(v, "batch")
        } else {
            const {
                url: t,
                event: a,
                headers: r
            } = e, v = n(a, m);
            u = l(v, i), o = s(r), d = t
        }
        var v;
        return o.SentAt = m, a.reclaimed && (o.Reclaimed = "true"), a.retryAttemptNumber > 0 && (o["Retry-Attempt"] = a.retryAttemptNumber.toString(), o["Retried-After"] = a.timeSinceLastAttempt.toString(), o["Retried-After-First"] = a.timeSinceFirstAttempt.toString()), {
            data: u,
            headers: o,
            url: d
        }
    },
    g = "XhrQueue",
    $ = () => ({
        name: g,
        deps: [],
        initialize: e => {
            e.plugins.loadedPlugins.value = [...e.plugins.loadedPlugins.value, g]
        },
        dataplaneEventsQueue: {
            init(e, a, n, s, l) {
                const i = e.lifecycle.writeKey.value;
                a.setAuthHeader(i);
                const u = (o = e.loadOptions.value.queueOptions, t(p, o));
                var o;
                return new c(`rudder_${i}`, u, ((t, r, n) => {
                    const {
                        data: s,
                        url: i,
                        headers: u
                    } = f(t, e, n, l);
                    a.getAsyncData({
                        url: i,
                        options: {
                            method: "POST",
                            headers: u,
                            data: s,
                            sendRawData: !0
                        },
                        isRawResponse: !0,
                        timeout: 3e4,
                        callback: (e, t) => {
                            var a, s;
                            if (d(null == t ? void 0 : t.error)) return void r(null);
                            const i = m(null !== (a = null == t || null === (s = t.xhr) || void 0 === s ? void 0 : s.status) && void 0 !== a ? a : 0);
                            R(t, i, n, l);
                            r(i ? t : null)
                        }
                    })
                }), n, v, l, (e => {
                    var t;
                    const a = r(),
                        n = e.map((e => e.event));
                    return null === (t = A(n, a, l)) || void 0 === t ? void 0 : t.length
                }))
            },
            enqueue(e, t, a, n, s) {
                a.sentAt = r(), u(a, s);
                const l = e.lifecycle.activeDataplaneUrl.value,
                    i = h(l, a.type),
                    d = {
                        AnonymousId: o(a.anonymousId)
                    };
                t.addItem({
                    url: i,
                    headers: d,
                    event: a
                })
            }
        }
    });
export {
    $ as XhrQueue, $ as
    default
};
//# sourceMappingURL=rsa-plugins-remote-XhrQueue.min.js.map